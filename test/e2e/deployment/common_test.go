//go:build integration

package deployment

import (
	"net/http"
	"time"

	"github.com/securesign/operator/internal/controller/tuf/constants"
	"github.com/securesign/operator/internal/labels"
	"github.com/securesign/operator/internal/utils/kubernetes"
	testSupportKubernetes "github.com/securesign/operator/test/e2e/support/kubernetes"
	"github.com/securesign/operator/test/e2e/support/steps"
	"github.com/securesign/operator/test/e2e/support/tas/securesign"
	"github.com/securesign/operator/test/e2e/support/tas/tsa"
	"github.com/securesign/operator/test/e2e/support/tas/tuf"
	v2 "k8s.io/api/networking/v1"
	"k8s.io/utils/ptr"

	"github.com/securesign/operator/test/e2e/support/tas"

	"github.com/securesign/operator/test/e2e/support/tas/fulcio"
	"github.com/securesign/operator/test/e2e/support/tas/rekor"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/matchers"
	"github.com/securesign/operator/api/v1alpha1"
	"github.com/securesign/operator/test/e2e/support"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
)

var _ = Describe("Install with generated certs and keys", Ordered, func() {
	cli, _ := support.CreateClient()

	var targetImageName string
	var namespace *v1.Namespace
	var s *v1alpha1.Securesign

	BeforeAll(steps.CreateNamespace(cli, func(new *v1.Namespace) {
		namespace = new
	}))

	BeforeAll(func(ctx SpecContext) {
		s = securesign.Create(namespace.Name, "test",
			securesign.WithDefaults(),
			securesign.WithSearchUI(),
			securesign.WithMonitoring(),
			func(v *v1alpha1.Securesign) {
				// cover SECURESIGN-2694
				v.Spec.Rekor.Attestations.Enabled = ptr.To(false)
			},
			func(v *v1alpha1.Securesign) {
				v.Spec.Tuf.ExternalAccess.RouteSelectorLabels = map[string]string{"foo": "bar"}
			},
		)
	})

	BeforeAll(func(ctx SpecContext) {
		targetImageName = support.PrepareImage(ctx)
	})

	Describe("Install with autogenerated certificates", func() {
		BeforeAll(func(ctx SpecContext) {
			Expect(cli.Create(ctx, s)).To(Succeed())
		})

		It("All other components are running", func(ctx SpecContext) {
			tas.VerifyAllComponents(ctx, cli, s, true)
		})

		It("operator should generate Fulcio's secret", func(ctx SpecContext) {
			Eventually(func(g Gomega) *v1.Secret {
				f := fulcio.Get(ctx, cli, namespace.Name, s.Name)
				g.Expect(f).ToNot(BeNil())
				g.Expect(f.Status.Certificate).ToNot(BeNil())
				g.Expect(f.Status.Certificate.PrivateKeyRef).ToNot(BeNil())
				scr := &v1.Secret{}
				g.Expect(cli.Get(ctx, types.NamespacedName{Namespace: namespace.Name, Name: f.Status.Certificate.PrivateKeyRef.Name}, scr)).To(Succeed())
				return scr
			}).Should(
				WithTransform(func(secret *v1.Secret) map[string][]byte { return secret.Data },
					And(
						&matchers.HaveKeyMatcher{Key: "cert"},
						&matchers.HaveKeyMatcher{Key: "private"},
						&matchers.HaveKeyMatcher{Key: "public"},
						&matchers.HaveKeyMatcher{Key: "password"},
					)))
		})

		It("operator should generate rekor secret", func(ctx SpecContext) {
			Eventually(func() *v1alpha1.SecretKeySelector {
				return rekor.Get(ctx, cli, namespace.Name, s.Name).Status.Signer.KeyRef
			}).Should(Not(BeNil()))
			Eventually(func(g Gomega) *v1.Secret {
				r := rekor.Get(ctx, cli, namespace.Name, s.Name)
				g.Expect(r).ToNot(BeNil())
				scr := &v1.Secret{}
				g.Expect(cli.Get(ctx, types.NamespacedName{Namespace: namespace.Name, Name: r.Status.Signer.KeyRef.Name}, scr)).To(Succeed())
				return scr
			}).Should(
				WithTransform(func(secret *v1.Secret) map[string][]byte { return secret.Data },
					And(
						&matchers.HaveKeyMatcher{Key: "private"},
					)))
		})

		It("operator should generate TSA secret", func(ctx SpecContext) {
			Eventually(func() *v1.Secret {
				tsa := tsa.Get(ctx, cli, namespace.Name, s.Name)
				scr := &v1.Secret{}
				Expect(cli.Get(ctx, types.NamespacedName{Namespace: namespace.Name, Name: tsa.Status.Signer.File.PrivateKeyRef.Name}, scr)).To(Succeed())
				return scr
			}).Should(
				WithTransform(func(secret *v1.Secret) map[string][]byte { return secret.Data },
					And(
						&matchers.HaveKeyMatcher{Key: "rootPrivateKey"},
						&matchers.HaveKeyMatcher{Key: "rootPrivateKeyPassword"},
						&matchers.HaveKeyMatcher{Key: "interPrivateKey-0"},
						&matchers.HaveKeyMatcher{Key: "interPrivateKeyPassword-0"},
						&matchers.HaveKeyMatcher{Key: "leafPrivateKey"},
						&matchers.HaveKeyMatcher{Key: "leafPrivateKeyPassword"},
						&matchers.HaveKeyMatcher{Key: "certificateChain"},
					)))
		})

		It("Fulcio is running with mounted certs", func(ctx SpecContext) {
			server := fulcio.GetServerPod(ctx, cli, namespace.Name)()
			Expect(server).NotTo(BeNil())

			sp := []v1.SecretProjection{}
			for _, volume := range server.Spec.Volumes {
				if volume.Name == "fulcio-cert" {
					for _, source := range volume.Projected.Sources {
						sp = append(sp, *source.Secret)
					}
				}
			}

			Expect(sp).To(
				ContainElement(
					WithTransform(func(sp v1.SecretProjection) string {
						return sp.Name
					}, Equal(fulcio.Get(ctx, cli, namespace.Name, s.Name).Status.Certificate.CARef.Name)),
				))
		})

		It("rekor is running with mounted certs", func(ctx SpecContext) {
			rekor.Verify(ctx, cli, namespace.Name, s.Name, true)
			server := rekor.GetServerPod(ctx, cli, namespace.Name)
			Expect(server).NotTo(BeNil())
			Expect(server.Spec.Volumes).To(
				ContainElement(
					WithTransform(func(volume v1.Volume) string {
						if volume.Secret != nil {
							return volume.Secret.SecretName
						}
						return ""
					}, Equal(rekor.Get(ctx, cli, namespace.Name, s.Name).Status.Signer.KeyRef.Name))),
			)

		})

		It("tsa is running with mounted keys and certs", func(ctx SpecContext) {
			tsa.Verify(ctx, cli, namespace.Name, s.Name)
			server := tsa.GetServerPod(ctx, cli, namespace.Name)()
			Expect(server).NotTo(BeNil())
			Expect(server.Spec.Volumes).To(
				ContainElement(
					WithTransform(func(volume v1.Volume) string {
						if volume.Secret != nil {
							return volume.Secret.SecretName
						}
						return ""
					}, Equal(tsa.Get(ctx, cli, namespace.Name, s.Name).Status.Signer.CertificateChain.CertificateChainRef.Name))),
			)
			Expect(server.Spec.Volumes).To(
				ContainElement(
					WithTransform(func(volume v1.Volume) string {
						if volume.Secret != nil {
							return volume.Secret.SecretName
						}
						return ""
					}, Equal(tsa.Get(ctx, cli, namespace.Name, s.Name).Status.Signer.File.PrivateKeyRef.Name))),
			)
		})

		It("ntp monitoring config created", func(ctx SpecContext) {
			tsa.Verify(ctx, cli, namespace.Name, s.Name)
			server := tsa.GetServerPod(ctx, cli, namespace.Name)()
			Expect(server).NotTo(BeNil())
			Expect(server.Spec.Volumes).To(
				ContainElement(
					WithTransform(func(volume v1.Volume) string {
						if volume.ConfigMap != nil {
							return volume.ConfigMap.Name
						}
						return ""
					}, Equal(tsa.Get(ctx, cli, namespace.Name, s.Name).Status.NTPMonitoring.Config.NtpConfigRef.Name))),
			)
		})

		It("Tuf repository root key secret was created", func(ctx SpecContext) {
			tuf.Verify(ctx, cli, namespace.Name, s.Name)
			tuf := tuf.Get(ctx, cli, namespace.Name, s.Name)
			Expect(tuf.Spec.RootKeySecretRef).NotTo(BeNil())
			Expect(cli.Get(ctx, types.NamespacedName{Namespace: namespace.Name, Name: tuf.Spec.RootKeySecretRef.Name}, &v1.Secret{})).To(Succeed())
		})

		It("All other components are running", func(ctx SpecContext) {
			tas.VerifyAllComponents(ctx, cli, s, true)
		})

		It("RouteSelectorLabels are passed to the ingress/route", func(ctx SpecContext) {
			ingress := &v2.Ingress{}
			Expect(cli.Get(ctx, types.NamespacedName{Namespace: namespace.Name, Name: constants.DeploymentName}, ingress)).To(Succeed())
			Expect(ingress.Labels).To(HaveKeyWithValue("foo", "bar"))

			if testSupportKubernetes.IsRemoteClusterOpenshift() {
				Expect(ingress.Annotations).To(HaveKeyWithValue("route.openshift.io/termination", "edge"))

				r, err := kubernetes.GetRoute(ctx, cli, namespace.Name, labels.ForComponent(constants.ComponentName, s.Name))
				Expect(err).To(Not(HaveOccurred()))
				Expect(r.Labels).To(HaveKeyWithValue("foo", "bar"))
			}
		})

		It("Verify Rekor Search UI is accessible", func(ctx SpecContext) {
			r := rekor.Get(ctx, cli, namespace.Name, s.Name)
			Expect(r).ToNot(BeNil())
			Expect(r.Status.RekorSearchUIUrl).NotTo(BeEmpty())

			httpClient := http.Client{
				Timeout: time.Second * 10,
			}
			Eventually(func() bool {
				resp, err := httpClient.Get(r.Status.RekorSearchUIUrl)
				if err != nil {
					return false
				}
				defer func() { _ = resp.Body.Close() }()
				return resp.StatusCode == http.StatusOK
			}, "30s", "1s").Should(BeTrue(), "Rekor UI should be accessible and return a status code of 200")
		})

		It("Use cosign cli", func(ctx SpecContext) {
			tas.VerifyByCosign(ctx, cli, s, targetImageName)
		})
	})
})
